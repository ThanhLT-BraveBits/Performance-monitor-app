import { PrismaClient, DeviceType, JobStatus, Prisma } from '@prisma/client';
import { 
  Product, 
  PerformanceMeasurement, 
  MeasurementJob, 
  PerformanceMetrics,
  ProductPerformanceData,
  DateRange 
} from '../types';

class DatabaseService {
  private prisma: PrismaClient;
  private useMockData = process.env.NODE_ENV === 'development';

  constructor() {
    try {
      this.prisma = new PrismaClient({
        log: ['query', 'error', 'warn'],
      });
    } catch (error) {
      console.warn('Database connection failed, using mock data');
      this.useMockData = true;
    }
  }

  // Mock data for demo
  private getMockProducts(): Product[] {
    return [
      {
        id: '1',
        name: 'Blum-celia',
        url: 'https://blum-celia.myshopify.com/',
        description: 'Shopify\'s flagship Blum theme demo store',
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: '2', 
        name: 'Blum-solie',
        url: 'https://blum-solie.myshopify.com/',
        description: 'Shopify Blum theme demo store',
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];
  }

  private getMockMeasurements(): PerformanceMeasurement[] {
    const now = new Date();
    return [
      {
        id: '1',
        productId: '1',
        deviceType: DeviceType.DESKTOP,
        measurementDate: now,
        performanceScore: 92,
        fcp: 1200,
        lcp: 2100,
        cls: 0.05,
        fid: 100,
        ttfb: 200,
        speedIndex: 1800,
        tbt: 150,
        opportunity: null,
        diagnostics: null,
        createdAt: now,
        updatedAt: now
      },
      {
        id: '2',
        productId: '1',
        deviceType: DeviceType.MOBILE,
        measurementDate: now,
        performanceScore: 78,
        fcp: 1800,
        lcp: 3200,
        cls: 0.08,
        fid: 200,
        ttfb: 400,
        speedIndex: 2800,
        tbt: 350,
        opportunity: null,
        diagnostics: null,
        createdAt: now,
        updatedAt: now
      }
    ];
  }

  // Product operations
  async getProducts(): Promise<Product[]> {
    if (this.useMockData) {
      return this.getMockProducts();
    }
    try {
      return await this.prisma.product.findMany({
        orderBy: { name: 'asc' }
      });
    } catch (error) {
      console.warn('Database error, using mock data:', error);
      return this.getMockProducts();
    }
  }

  async getActiveProducts(): Promise<Product[]> {
    if (this.useMockData) {
      return this.getMockProducts().filter(p => p.isActive);
    }
    try {
      return await this.prisma.product.findMany({
        where: { isActive: true },
        orderBy: { name: 'asc' }
      });
    } catch (error) {
      console.warn('Database error, using mock data:', error);
      return this.getMockProducts().filter(p => p.isActive);
    }
  }

  async getProductById(id: string): Promise<Product | null> {
    return this.prisma.product.findUnique({
      where: { id }
    });
  }

  async createProduct(data: {
    name: string;
    url: string;
    description?: string;
    isActive?: boolean;
  }): Promise<Product> {
    return this.prisma.product.create({
      data
    });
  }

  async updateProduct(id: string, data: {
    name?: string;
    url?: string;
    description?: string;
    isActive?: boolean;
  }): Promise<Product> {
    return this.prisma.product.update({
      where: { id },
      data
    });
  }

  async deleteProduct(id: string): Promise<void> {
    await this.prisma.product.delete({
      where: { id }
    });
  }

  async findProductByUrl(url: string): Promise<Product | null> {
    return this.prisma.product.findFirst({
      where: { url }
    });
  }

  // Performance measurement operations
  async createMeasurement(data: {
    productId: string;
    deviceType: DeviceType;
    performanceScore: number;
    fcp?: number | null;
    lcp?: number | null;
    cls?: number | null;
    fid?: number | null;
    ttfb?: number | null;
    speedIndex?: number | null;
    tbt?: number | null;
    opportunity?: Prisma.JsonValue | null;
    diagnostics?: Prisma.JsonValue | null;
    measurementDate?: Date;
  }): Promise<PerformanceMeasurement> {
    return this.prisma.performanceMeasurement.create({
      data: {
        ...data,
        measurementDate: data.measurementDate || new Date()
      },
      include: {
        product: true
      }
    });
  }

  async getMeasurements(options: {
    productId?: string;
    deviceType?: DeviceType;
    dateRange?: DateRange;
    limit?: number;
    offset?: number;
  } = {}): Promise<PerformanceMeasurement[]> {
    if (this.useMockData) {
      let measurements = this.getMockMeasurements();
      
      // Apply filters
      if (options.productId) {
        measurements = measurements.filter(m => m.productId === options.productId);
      }
      if (options.deviceType) {
        measurements = measurements.filter(m => m.deviceType === options.deviceType);
      }
      if (options.limit) {
        measurements = measurements.slice(0, options.limit);
      }
      
      return measurements;
    }

    try {
      const { productId, deviceType, dateRange, limit, offset } = options;

      return await this.prisma.performanceMeasurement.findMany({
        where: {
          ...(productId && { productId }),
          ...(deviceType && { deviceType }),
          ...(dateRange && {
            measurementDate: {
              gte: dateRange.from,
              lte: dateRange.to
            }
          })
        },
        include: {
          product: true
        },
        orderBy: { measurementDate: 'desc' },
        ...(limit && { take: limit }),
        ...(offset && { skip: offset })
      });
    } catch (error) {
      console.warn('Database error, using mock data:', error);
      return this.getMockMeasurements();
    }
  }

  async getLatestMeasurements(productId: string): Promise<{
    desktop?: PerformanceMeasurement;
    mobile?: PerformanceMeasurement;
  }> {
    const [desktop, mobile] = await Promise.all([
      this.prisma.performanceMeasurement.findFirst({
        where: {
          productId,
          deviceType: DeviceType.DESKTOP
        },
        orderBy: { measurementDate: 'desc' },
        include: { product: true }
      }),
      this.prisma.performanceMeasurement.findFirst({
        where: {
          productId,
          deviceType: DeviceType.MOBILE
        },
        orderBy: { measurementDate: 'desc' },
        include: { product: true }
      })
    ]);

    return { desktop, mobile };
  }

  async getAverageScores(productId: string, days: number = 30): Promise<{
    desktop: number;
    mobile: number;
  }> {
    const since = new Date();
    since.setDate(since.getDate() - days);

    const [desktopAvg, mobileAvg] = await Promise.all([
      this.prisma.performanceMeasurement.aggregate({
        where: {
          productId,
          deviceType: DeviceType.DESKTOP,
          measurementDate: { gte: since }
        },
        _avg: { performanceScore: true }
      }),
      this.prisma.performanceMeasurement.aggregate({
        where: {
          productId,
          deviceType: DeviceType.MOBILE,
          measurementDate: { gte: since }
        },
        _avg: { performanceScore: true }
      })
    ]);

    return {
      desktop: Math.round(desktopAvg._avg.performanceScore || 0),
      mobile: Math.round(mobileAvg._avg.performanceScore || 0)
    };
  }

  async getProductPerformanceData(): Promise<ProductPerformanceData[]> {
    const products = await this.getActiveProducts();
    
    const performanceData = await Promise.all(
      products.map(async (product) => {
        const [latestMeasurements, averageScores, measurements] = await Promise.all([
          this.getLatestMeasurements(product.id),
          this.getAverageScores(product.id),
          this.getMeasurements({ productId: product.id, limit: 30 })
        ]);

        return {
          product,
          latestDesktop: latestMeasurements.desktop,
          latestMobile: latestMeasurements.mobile,
          measurements,
          averageScore: averageScores
        };
      })
    );

    return performanceData;
  }

  // Measurement job operations
  async createMeasurementJob(data: {
    productId: string;
    deviceType: DeviceType;
    scheduledAt: Date;
  }): Promise<MeasurementJob> {
    return this.prisma.measurementJob.create({
      data
    });
  }

  async getPendingJobs(): Promise<MeasurementJob[]> {
    return this.prisma.measurementJob.findMany({
      where: {
        status: JobStatus.PENDING,
        scheduledAt: { lte: new Date() }
      },
      orderBy: { scheduledAt: 'asc' }
    });
  }

  async updateJobStatus(jobId: string, data: {
    status: JobStatus;
    startedAt?: Date;
    completedAt?: Date;
    errorMessage?: string;
    retryCount?: number;
  }): Promise<MeasurementJob> {
    return this.prisma.measurementJob.update({
      where: { id: jobId },
      data
    });
  }

  async cleanupOldJobs(daysOld: number = 30): Promise<number> {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysOld);

    const result = await this.prisma.measurementJob.deleteMany({
      where: {
        status: { in: [JobStatus.COMPLETED, JobStatus.FAILED] },
        completedAt: { lt: cutoff }
      }
    });

    return result.count;
  }

  async getMeasurementJobs(options: {
    status?: JobStatus;
    limit?: number;
  } = {}) {
    return this.prisma.measurementJob.findMany({
      where: options.status ? { status: options.status } : {},
      orderBy: { createdAt: 'desc' },
      take: options.limit || 50,
      include: {
        product: {
          select: { name: true, url: true }
        }
      }
    });
  }

  async getJobStats(hoursAgo: number = 24) {
    return this.prisma.measurementJob.groupBy({
      by: ['status'],
      _count: true,
      where: {
        createdAt: {
          gte: new Date(Date.now() - hoursAgo * 60 * 60 * 1000)
        }
      }
    });
  }

  // System configuration
  async getConfig(key: string): Promise<string | null> {
    const config = await this.prisma.systemConfig.findUnique({
      where: { key }
    });
    return config?.value || null;
  }

  async setConfig(key: string, value: string): Promise<void> {
    await this.prisma.systemConfig.upsert({
      where: { key },
      create: { key, value },
      update: { value }
    });
  }

  // Analytics and reporting
  async getTotalMeasurements(): Promise<number> {
    return this.prisma.performanceMeasurement.count();
  }

  async getLastUpdated(): Promise<Date | null> {
    const latest = await this.prisma.performanceMeasurement.findFirst({
      orderBy: { measurementDate: 'desc' },
      select: { measurementDate: true }
    });
    
    return latest?.measurementDate || null;
  }

  async getMeasurementStats(dateRange?: DateRange) {
    const where = dateRange ? {
      measurementDate: {
        gte: dateRange.from,
        lte: dateRange.to
      }
    } : {};

    const [total, avgDesktop, avgMobile, byDevice] = await Promise.all([
      this.prisma.performanceMeasurement.count({ where }),
      this.prisma.performanceMeasurement.aggregate({
        where: { ...where, deviceType: DeviceType.DESKTOP },
        _avg: { performanceScore: true }
      }),
      this.prisma.performanceMeasurement.aggregate({
        where: { ...where, deviceType: DeviceType.MOBILE },
        _avg: { performanceScore: true }
      }),
      this.prisma.performanceMeasurement.groupBy({
        by: ['deviceType'],
        where,
        _count: true,
        _avg: { performanceScore: true }
      })
    ]);

    return {
      total,
      averageScores: {
        desktop: Math.round(avgDesktop._avg.performanceScore || 0),
        mobile: Math.round(avgMobile._avg.performanceScore || 0)
      },
      deviceBreakdown: byDevice
    };
  }

  // Database utilities
  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }

  async healthCheck(): Promise<boolean> {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return true;
    } catch {
      return false;
    }
  }
}

// Singleton instance
let databaseService: DatabaseService | null = null;

export function getDatabaseService(): DatabaseService {
  if (!databaseService) {
    databaseService = new DatabaseService();
  }
  return databaseService;
}

// Export for testing
export function resetDatabaseService(): void {
  if (databaseService) {
    databaseService.disconnect();
    databaseService = null;
  }
}
